## 쓰레기, 쓰레기 천지 {#garbage}

![Garbage Day](../../images/garbage.jpg)
    
우리는 이제 꼬리 호출(Tail Calls)을 사용하여 mapWith를 일정한 공간에서 실행하는 방법을 살펴보았습니다.

```js
const mapWith = (fn, [first, ...rest], prepend = []) =>
  first === undefined
    ? prepend
    : mapWith(fn, rest, [...prepend, fn(first)]);
                                                  
mapWith((x) => x * x, [1, 2, 3, 4, 5])
  //=> [1,4,9,16,25]
```

하지만 매우 큰 배열에 대해 실행해보면 *여전히* 매우 느리다는 것을 발견합니다. 배열의 내장 `.map` 메서드보다 훨씬 느립니다. 이 느린 이유를 알아내기 위해 메모리 프로파일러를 사용할 수도 있지만, 단순히 코드를 검토해보면 다음과 같은 문제가 드러납니다:

`mapWith`를 호출할 때마다 `[...prepend, fn(first)]`가 호출됩니다. 이를 수행하기 위해 `prepend` 배열의 요소들을 복사하여 `fn(first)`를 맨 끝에 추가하고, 새로운 배열을 생성하여 다음 `mapWith` 호출에 전달합니다.

더 나쁜 것은, JavaScript 엔진이 prepend의 요소들을 하나씩 새 배열에 복사한다는 점입니다. 이것은 매우 귀찮고 많은 작업을 필요로 합니다.[^cow]

[^cow]: 항상 그런 것은 아닙니다. 프로그래머들은 기본적으로 공통 요소를 공유하고, 변경이 발생할 때만 복사하는 특수한 데이터 구조를 개발해왔습니다. 그러나 JavaScript의 기본 배열은 그렇게 작동하지 않습니다. 

`prepend`에 있던 배열은 더 이상 사용되지 않습니다. `GC` 환경에서는 이 배열이 더 이상 사용되지 않는 것으로 표시되고, 결국 가비지 컬렉터가 이 메모리를 회수합니다. 반복, 반복, 반복: `mapWith`를 호출할 때마다 새로운 배열을 생성하고, `prepend`의 요소들을 복사하여 버려지게 됩니다.

우리가 3,000개의 스택 프레임을 생성하는 것은 아니지만, 여전히 수천 개의 새로운 배열을 만들고, 각 배열에 요소를 복사하는 작업을 반복합니다. 최대 메모리 사용량은 증가하지 않지만, 짧은 수명의 배열이 반복적으로 생성되는 것은 성능에 큰 영향을 미치며, 요소를 복사하는 데 많은 작업을 필요로 합니다.

> **핵심 포인트**: `[first, ...rest]`를 사용하는 재귀 방법은 많은 임시 배열을 생성하고, 결국 버려지는 배열들에 많은 시간을 낭비하기 때문에 느립니다.

그렇다면 이렇게 느린 접근법을 사용하는 "함수형" 알고리즘 예제가 존재하는 이유는 무엇일까요?

![The IBM 704](../../images/IBM704b.jpg)

### 약간의 역사

옛날에 Lisp이라는 프로그래밍 언어가 있었습니다. Lisp는 LISt Processing(목록 처리)의 약자였습니다.[^lisp] Lisp는 초기 고급 언어 중 하나였고, 처음 구현된 버전은 IBM 704 컴퓨터를 위해 작성되었습니다. (FORTRAN의 초기 구현도 704에서 작성되었습니다).

[Lisp]: https://en.wikipedia.org/wiki/Lisp_(programming_language)
[IBM 704]: https://en.wikipedia.org/wiki/IBM_704
[^lisp]: Lisp is still very much alive, and one of the most interesting and exciting programming languages in use today is [Clojure](http://clojure.org/), a Lisp dialect that runs on the JVM, along with its sibling [ClojureScript](https://github.com/clojure/clojurescript), Clojure that transpiles to JavaScript.

704는 36비트 단어(word)를 가졌으며, 이는 36비트 값을 저장하고 가져오는 데 매우 빠르게 작동했습니다. CPU의 명령 집합에는 두 가지 중요한 매크로가 있었습니다. CAR은 레지스터의 주소 부분 내용을 가져오고, CDR은 레지스터의 감소 부분 내용을 가져옵니다.

대략적으로 말하자면, 이는 단일 36비트 단어가 두 개의 15비트 값을 저장할 수 있음을 의미하며, 쌍의 값을 저장하고 가져오는 데 매우 빠릅니다. 두 개의 15비트 값을 가지고 이를 레지스터에 쓰고자 한다면, CONS 매크로는 이 값을 가져와서 36비트 단어에 씁니다.

따라서 `CONS`는 두 값을 결합하고, `CAR`는 하나를 추출하며, `CDR`은 나머지를 추출합니다. Lisp의 기본 데이터 유형은 종종 목록이라고 하지만 실제로는 "컨스 셀(cons cell)"이라고 불리는 두 개의 15비트 값을 가진 작은 데이터 구조입니다. 15비트 값은 메모리 위치를 참조할 수 있는 포인터로 사용되므로, 실제로 컨스 셀은 다른 컨스 셀을 가리키는 두 개의 포인터를 가진 작은 데이터 구조입니다.

리스트는 컨스 셀의 링크드 리스트(linked list)로 표현되며, 각 셀의 머리는 요소를 가리키고, 꼬리는 다른 컨스 셀을 가리킵니다.

> 이러한 명령들이 매우 빠르게 실행되는 것은 초기 설계자들에게 중요했습니다. 그들은 최초의 고급 언어 중 하나를 개발하고 있었으며 (다른 언어로는 COBOL과 FORTRAN이 있었습니다), 1950년대 후반의 컴퓨터는 오늘날에 비해 매우 작고 느렸습니다. 704는 코어 메모리를 사용했지만, 논리 부분에서는 여전히 진공관을 사용했습니다. 따라서 프로그래밍 언어와 알고리즘 설계는 제한된 메모리와 성능으로 무엇을 할 수 있는지가 기준이 되었습니다

JavaScript에서 두 요소 배열을 사용하여 컨스 셀을 구현한 예제는 다음과 같습니다:

```js
const cons = (a, d) => [a, d],
      car  = ([a, d]) => a,
      cdr  = ([a, d]) => d;
```
      
`cons`를 반복 호출하고 `null`로 종료하여 리스트를 만들 수 있습니다:

```js
const oneToFive = cons(1, cons(2, cons(3, cons(4, cons(5, null)))));

oneToFive
  //=> [1,[2,[3,[4,[5,null]]]]]
```

JavaScript가 리스트를 중첩 배열로 표시하지만 실제로는 참조로 서로를 가리키므로 `[1,[2,[3,[4,[5,null]]]]]`는 실제로 다음과 같습니다:


```js
const node5 = [5,null],
      node4 = [4, node5],
      node3 = [3, node4],
      node2 = [2, node3],
      node1 = [1, node2];
    
const oneToFive = node1;
```

이것이 바로 링크드 리스트입니다. 초기 `Lisp` 사용자들은 하드웨어 명령에 따라 `car`와 `cdr`이라는 이름을 사용했지만, 오늘날 우리는 `data`와 `reference` 같은 용어를 사용합니다. 그러나 동일한 방식으로 작동합니다. 리스트의 첫 번째 요소가 필요하면 `car`를 호출하면 됩니다:


```js
car(oneToFive)
  //=> 1
```
      
`car`는 매우 빠릅니다. 컨스 셀의 첫 번째 요소를 추출할 뿐입니다.

그러나 리스트의 나머지 요소는 어떻게 할까요? `cdr`이 해결해 줍니다:

```js
cdr(oneToFive)
  //=> [2,[3,[4,[5,null]]]]
```
      
이 역시 컨스 셀에서 참조를 추출하는 것이므로 매우 빠릅니다. Lisp에서는 하드웨어 수준에서 실행되므로 매우 빠릅니다. 새로운 구조물을 생성하지 않고 이미 존재하는 참조를 가져오는 것이 배열에서 요소를 복사하는 것보다 훨씬 빠릅니다.

이제 우리가 알 수 있는 것은 Lisp에서 많은 것들이 링크드 리스트를 사용한다는 것입니다. 부분적으로는 하드웨어가 가능하게 했기 때문입니다.

JavaScript에서 `[first, ...rest]`를 사용해 배열을 쪼개거나 펼칠 때 `car`와 `cdr`의 의미를 모방하지만 구현은 그렇지 않습니다. 복사와 메모리 비효율성 측면에서 링크드 리스트를 사용하는 것보다 느립니다.

그럼에도 불구하고 이 방식은 문법적으로 이해하기 쉽고, 리터럴과 구조 분해(destructuring)가 작동하는 방식, 그리고 재귀 알고리즘이 처리해야 하는 데이터 구조의 자기 유사성을 이해하는 데 도움이 됩니다. 그래서 JavaScript와 같은 언어들은 배열이 느리게 분리된다는 것을 알지만, 재귀적 프로그램의 교육용 예제들은 여전히 `Lisp`의 흔적을 남기고 있습니다.

We'll look at linked lists again when we look at [Plain Old JavaScript Objects](#pojos).

### 왜 배열인가?

`[first, ...rest]`가 느리다면, 왜 자바스크립트는 모든 것을 링크드 리스트로 만드는 대신 배열을 사용할까요?

링크드 리스트는 리스트의 앞쪽 요소를 가져오거나 나머지 리스트를 가져올 때는 빠르게 작동합니다. 하지만 리스트를 반복(iterate)하는 데는 적합하지 않습니다. 메모리의 포인터를 따라가는 것은 인덱스를 증가시키는 것보다 훨씬 느립니다. 포인터를 역참조하기 위해 추가적으로 데이터를 가져와야 하고, 이 과정에서 캐시 미스가 발생할 수 있습니다. 게다가 리스트에서 임의의 요소를 가져오려면, 리스트를 처음부터 차례로 탐색해야 합니다. 반면에 인덱스가 있는 배열에서는 그저 해당 요소를 바로 가져오기만 하면 됩니다.

값을 다시 바인딩하거나 변경하는 것에 대해서는 논의하지 않았지만, 리스트의 요소를 변경하고자 한다면 링크드 리스트는 문제를 겪게 됩니다. 리스트의 cdr을 가져오면 그 요소들이 공유됩니다. 리스트의 앞에 새로운 요소를 추가하는 것 이외에 다른 변경을 가하게 되면, 새 리스트와 기존 리스트가 동시에 영향을 받게 됩니다.

배열은 이런 문제를 피하기 위해 요소나 일부분을 추출할 때마다 모든 참조를 복사하는 방식으로 동작합니다. (이 부분은 이후 변경(Mutation)에서 설명될 예정입니다).

이러한 이유들 외에도 대부분의 현대 프로그래밍 언어는 반복을 최적화한 빠른 배열 또는 벡터 타입을 지원합니다. 심지어 Lisp조차도 특정 용도에 맞춘 다양한 데이터 구조를 제공합니다.

### 요약

우리는 `[first, ...rest]`를 이용하여 배열에 대해 꼬리 호출을 사용해 맵과 폴드를 수행하는 방법을 알아보았습니다. 그러나 실제로는 이러한 방식이 이상적이지 않습니다. 하지만 이는 데이터 구조를 자기 유사적(self-similar)으로 구성할 수 있을 때 재귀가 어떻게 작동하는지를 매우 간단하게 보여주는 예시로서 가치가 있습니다.

