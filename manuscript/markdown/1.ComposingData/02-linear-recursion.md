## 자기 유사성 {#linear-recursion}

> 재귀는 계산의 근원입니다. 왜냐하면 재귀는 설명을 시간과 맞바꾸기 때문입니다. —[Epigrams in Programming](http://www.cs.yale.edu/homes/perlis-alan/quotes.html)

배열과 매개변수 분해에서, 우리는 리터럴 배열 표현식으로 배열을 만드는 것이 분해 할당으로 배열을 분해하는 것의 반대라는 기본 개념을 다뤘습니다.

우리는 리터럴 배열 표현식으로 배열을 만드는 것이 분해 할당으로 배열을 분해하는 것의 반대라는 기본 개념을 살펴보았습니다.

더 구체적으로 살펴봅시다. 리스트와 같은 일부 데이터 구조는 분명히 항목의 모음으로 볼 수 있습니다. 어떤 것은 비어있고, 어떤 것은 세 개의 항목을 가지고 있으며, 어떤 것은 42개를, 어떤 것은 숫자를 포함하고, 어떤 것은 문자열을, 어떤 것은 여러 요소의 혼합을 포함하는 등 모든 종류의 리스트가 있습니다.

하지만 우리는 리스트를 만드는 규칙을 설명함으로써 리스트를 정의할 수도 있습니다. 컴퓨터 과학에서 가장 오래되고 단순한 규칙 중 하나는 리스트를 다음과 같이 정의하는 것입니다:

0. 비어있거나;
1. 하나의 요소와 리스트를 연결한 것으로 구성됨.

이 규칙들을 배열 리터럴로 변환해봅시다. 첫 번째 규칙은 간단합니다: `[]`가 리스트입니다. 두 번째 규칙은 어떨까요? 스프레드를 사용하여 표현할 수 있습니다. 요소 e와 리스트 list가 주어졌을 때, `[e, ...list]`는 리스트입니다. 이것을 수동으로 리스트를 만들어가며 테스트해볼 수 있습니다:

    []
    //=> []

    ["baz", ...[]]
    //=> ["baz"]

    ["bar", ...["baz"]]
    //=> ["bar","baz"]

    ["foo", ...["bar", "baz"]]
    //=> ["foo","bar","baz"]
  
배열 리터럴 + 스프레드와 분해 + 나머지 매개변수 사이의 유사성 덕분에, 우리는 같은 규칙을 사용하여 리스트를 분해할 수도 있습니다:
    
    const [first, ...rest] = [];
    first
      //=> undefined
    rest
      //=> []:

    const [first, ...rest] = ["foo"];
    first
      //=> "foo"
    rest
      //=> []

    const [first, ...rest] = ["foo", "bar"];
    first
      //=> "foo"
    rest
      //=> ["bar"]

    const [first, ...rest] = ["foo", "bar", "baz"];
    first
      //=> "foo"
    rest
      //=> ["bar","baz"]
    

이 탐구를 위해, 우리는 다음을 가정하겠습니다:[^wellactually]

    
    const isEmpty = ([first, ...rest]) => first === undefined;

    isEmpty([])
      //=> true

    isEmpty([0])
      //=> false

    isEmpty([[]])
      //=> false
    
    
[^wellactually]: 사실, 이것은 `undefined를` 값으로 포함하는 배열에서는 작동하지 않지만, 우리의 예제에서는 그런 경우를 보지 않을 것입니다. 더 견고한 구현은 `(array) => array.length === 0`이 되겠지만, 우리는 매우 작고 인위적인 실험 환경 안에서 작업하고 있습니다.

빈 리스트의 정의와 우리가 이미 배운 것들을 가지고, 우리는 배열에 대해 작동하는 많은 함수들을 만들 수 있습니다. 우리는 배열의 길이를 .length를 사용하여 얻을 수 있다는 것을 알고 있습니다. 하지만 연습으로서, 우리가 이미 가지고 있는 것들만 사용하여 length 함수를 어떻게 작성할 수 있을까요?

먼저, 우리가 *종료 케이스*라고 부르는 것을 선택합니다. 빈 배열의 길이는 얼마일까요? `0`입니다. 그래서 배열이 비어있다면 길이가 `0`이라는 관찰로 함수를 시작합시다:

    const length = ([first, ...rest]) =>
      first === undefined
        ? 0
        : // ???
    
      
배열이 비어있지 않을 때를 위한 무언가가 필요합니다. 배열이 비어있지 않고, 우리가 그것을 `first`와 `rest` 두 부분으로 나눈다면, 우리 배열의 길이는 `length(first) + length(rest)`가 될 것입니다. 음, `first`의 길이는 `1`입니다, 앞에는 단 하나의 요소만 있습니다. 하지만 우리는 `rest`의 길이를 모릅니다. 우리가 호출할 수 있는 함수가 있다면... `length`처럼요!

    
    const length = ([first, ...rest]) =>
      first === undefined
        ? 0
        : 1 + length(rest);
    
    
Let's try it!

    
    length([])
      //=> 0
  
    length(["foo"])
      //=> 1
  
    length(["foo", "bar", "baz"])
      //=> 3
    
      
우리의 `length` 함수는 *재귀적*입니다, 자기 자신을 호출합니다. 이것은 우리의 리스트 정의가 재귀적이기 때문에 이해가 되며, 리스트가 자기 유사적이라면 자기 유사적인 알고리즘을 만드는 것이 자연스럽습니다.

### 선형 재귀

"재귀"는 때때로 정교한 파티 트릭처럼 보입니다. 이에 대한 농담도 있습니다:

> 유망한 학생들이 순수 수학과 응용 공학 중에서 선택하려고 할 때, 그들은 두 부분으로 된 적성 검사를 받습니다. 첫 번째 부분에서, 그들은 실험실 작업대로 안내되어 카드에 인쇄된 지시사항을 따르라고 합니다. 그들은 분젠 버너, 점화기, 수도꼭지, 빈 비커, 스탠드, 그리고 "물을 끓이시오"라는 지시사항이 적힌 카드를 발견합니다.

> 물론, 모든 학생들은 무엇을 해야 하는지 알고 있습니다: 그들은 비커에 물을 채우고, 버너 위에 스탠드를 놓고 스탠드 위에 비커를 놓은 다음, 버너를 켜고 점화기를 사용하여 불을 붙입니다. 잠시 후 물이 끓으면, 그들은 버너를 끄고 두 번째 작업대로 안내됩니다.

> 다시 한 번, "물을 끓이시오"라고 적힌 카드가 있습니다. 하지만 이번에는 이전 학생이 남겨놓은 대로 비커가 이미 스탠드 위 버너에 놓여있습니다. 공학도들은 즉시 버너에 불을 붙입니다. 반면에 수학자들은 비커를 스탠드에서 내려 비운 다음, 그들이 이미 해결했던 문제로 상황을 환원시킵니다.

단순히 자기 자신을 호출하는 함수들 이상으로 재귀적 해결책에는 더 많은 것이 있습니다. 재귀 알고리즘은 문제를 해결하기 위한 "분할 정복" 전략을 따릅니다:

0. 문제를 더 작은 문제들로 나눕니다
1. 더 작은 문제가 해결 가능하다면, 그 작은 문제를 해결합니다
2. 더 작은 문제가 해결 가능하지 않다면, 그 문제를 분할 정복합니다
3. 모든 작은 문제들이 해결되었을 때, 해결책들을 하나의 큰 해결책으로 구성합니다

분할 정복의 큰 요소들은 문제를 더 작은 문제들로 분해하는 방법, 가능한 가장 작은 문제에 대한 테스트, 그리고 조각들을 다시 맞추는 방법입니다. 우리의 해결책들은 실제로 문제를 여러 조각으로 나누지 않고, 해결 가능하거나 가능하지 않을 수 있는 문제의 일부를 떼어내어, 그것을 해결한 후 나머지 문제의 해결책에 붙이는 방식이라서 조금 더 단순합니다.

이런 더 단순한 형태의 "분할 정복"을 선형 재귀라고 합니다. 이것은 매우 유용하고 이해하기 쉽습니다. 다른 예를 살펴보겠습니다. 때때로 우리는 배열을 평탄화하고 싶습니다, 즉 배열들의 배열을 배열이 아닌 요소들의 하나의 배열로 바꾸고 싶습니다.[^unfold]

[^unfold]: flatten은 매우 단순한 펼침으로[unfold](https://en.wikipedia.org/wiki/Anamorphism), 시드 값을 받아서 배열로 바꾸는 함수입니다. 펼침은 데이터 구조를 통과하는 "경로"로 생각할 수 있으며, 트리를 평탄화하는 것은 깊이-우선 순회와 동일합니다

우리는 이미 배열을 더 작은 조각들로 나누는 방법을 알고 있습니다. 더 작은 문제가 해결 가능한지 어떻게 결정할까요? 종료 케이스를 위한 테스트가 필요합니다. 다행히도, 우리를 위해 제공된 것이 있습니다:

    Array.isArray("foo")
      //=> false
      
    Array.isArray(["foo"])
      //=> true
      
일반적인 "종료 케이스"는 빈 배열을 평탄화하면 빈 배열이 된다는 것입니다. 다음 종료 케이스는 요소가 배열이 아니라면, 우리는 그것을 평탄화하지 않고 직접 우리의 해결책과 함께 조합할 수 있다는 것입니다. 반면에 요소가 배열이라면, 우리는 그것을 평탄화하고 우리의 해결책의 나머지 부분과 함께 조합할 것입니다.

그래서 우리의 첫 `flatten` 함수는 이렇게 보일 것입니다:

    const flatten = ([first, ...rest]) => {
      if (first === undefined) {
        return [];
      }
      else if (!Array.isArray(first)) {
        return [first, ...flatten(rest)];
      }
      else {
        return [...flatten(first), ...flatten(rest)];
      }
    }
    
    flatten(["foo", [3, 4, []]])
      //=> ["foo",3,4]
      
다시 한 번, 이 해결책은 중요한 요소들을 직접적으로 보여줍니다: 문제를 하위 문제들로 나누기, 종료 케이스 감지하기, 종료 케이스 해결하기, 그리고 해결된 부분들로부터 해결책을 구성하기.

### 매핑 {#mapping}

또 다른 일반적인 문제는 배열의 모든 요소에 함수를 적용하는 것입니다. JavaScript는 이를 위한 내장 함수를 가지고 있지만, 선형 재귀를 사용하여 우리만의 것을 작성해봅시다.

리스트의 각 숫자를 제곱하고 싶다면, 우리는 이렇게 작성할 수 있습니다:

    const squareAll = ([first, ...rest]) => first === undefined
                                                ? []
                                                : [first * first, ...squareAll(rest)];
                                                
    squareAll([1, 2, 3, 4, 5])
      //=> [1,4,9,16,25]

그리고 리스트의 각 요소를 "참/거짓" 값으로 변환하고 싶다면 이렇게 작성할 수 있습니다:

    const truthyAll = ([first, ...rest]) => first === undefined
                                                ? []
                                                : [!!first, ...truthyAll(rest)];

    truthyAll([null, true, 25, false, "foo"])
      //=> [false,true,true,false,true]
                                                
이러한 선형 재귀의 특정 경우를 "매핑"이라고 하며, 동일한 패턴을 계속해서 작성할 필요가 없습니다. 함수는 함수를 인자로 받을 수 있으므로, 각 요소에 수행할 작업을 "추출"하여 배열을 분해하고, 작업을 수행하고, 배열을 다시 조합하는 작업과 분리해봅시다.

다음과 같은 함수 시그니처가 주어졌을 때:

    const mapWith = (fn, array) => // ...
    
삼항 연산자를 사용하여 작성할 수 있습니다. 이 작은 함수에서도 종료 조건, 분해되는 부분, 그리고 해결책을 재구성하는 방법을 식별할 수 있습니다.

    const mapWith = (fn, [first, ...rest]) =>
      first === undefined
        ? []
        : [fn(first), ...mapWith(fn, rest)];
                                                  
    mapWith((x) => x * x, [1, 2, 3, 4, 5])
      //=> [1,4,9,16,25]
      
    mapWith((x) => !!x, [null, true, 25, false, "foo"])
      //=> [false,true,true,false,true]

### 폴딩

처음의 `length` 예제를 제외하고, 지금까지의 예제들은 모두 스프레드를 사용하여 해결책을 재구성하는 것이었습니다. 하지만 반드시 그럴 필요는 없습니다. 숫자 리스트의 제곱의 합을 계산하는 함수는 다음과 같이 작성할 수 있습니다:

    const sumSquares = ([first, ...rest]) => first === undefined
                                             ? 0
                                             : first * first + sumSquares(rest);
                                             
    sumSquares([1, 2, 3, 4, 5])
      //=> 55

위의 맵들과 `sumSquares`의 두 가지 차이점이 있습니다:


0. 빈 리스트의 종료 케이스에서 빈 리스트 대신 0을 반환합니다.
1. 각 요소의 제곱을 나머지 요소들에 sumSquares를 적용한 결과에 연결합니다.

제곱의 합을 계산할 수 있도록 `mapWith`를 다시 작성해봅시다.

    const foldWith = (fn, terminalValue, [first, ...rest]) =>
      first === undefined
        ? terminalValue
        : fn(first, foldWith(fn, terminalValue, rest));
                                                           
이제 매핑 함수들보다 약간 더 많은 작업을 수행하는 함수를 제공합니다:

    foldWith((number, rest) => number * number + rest, 0, [1, 2, 3, 4, 5])
      //=> 55

우리의 `foldWith` 함수는 `mapWith` 함수의 일반화입니다. 맵을 폴드로 표현할 수 있습니다. 배열을 재구성하는 코드만 제공하면 됩니다:

    const squareAll = (array) => foldWith((first, rest) => [first * first, ...rest], [], array);
    
    squareAll([1, 2, 3, 4, 5])
      //=> [1,4,9,16,25]

그리고 원한다면 `foldWith`를 사용하여 `mapWith`를 작성할 수 있습니다:

    const mapWith = (fn, array) => foldWith((first, rest) => [fn(first), ...rest], [], array),
          squareAll = (array) => mapWith((x) => x * x, array);
    
    squareAll([1, 2, 3, 4, 5])
      //=> [1,4,9,16,25]
          
그리고 첫 번째 예제로 돌아가서, 우리의 `length` 버전을 폴드로 작성할 수 있습니다:

    const length = (array) => foldWith((first, rest) => 1 + rest, 0, array);
    
    length([1, 2, 3, 4, 5])
      //=> 5
          
### 요약약

선형 재귀는 알고리즘의 기본 구성 요소입니다. 그것의 기본 형태는 리스트와 같은 선형 데이터 구조가 구성되는 방식과 평행합니다: 이는 이해하기 쉽게 만듭니다. 매핑과 폴딩의 특수한 경우는 특히 유용하며 다른 함수들을 구축하는 데 사용될 수 있습니다. 그리고 마지막으로, 폴딩이 선형 재귀의 특수한 경우인 반면, 매핑은 폴딩의 특수한 경우입니다.    
