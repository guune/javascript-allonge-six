##  꼬리 호출(및 기본 인수) {#tail}

자기 유사성에서 작성한 `mapWith`와 `foldWith` 함수는 재귀를 사용해 자기 유사 데이터 구조로 작업하는 기본 원칙을 설명하는 데 유용하지만, “프로덕션에 바로 사용할 수 있는” 구현은 아닙니다. 프로덕션에 사용할 수 없는 이유 중 하나는 폴딩되는 배열의 크기에 비례하여 메모리를 소비하기 때문입니다.

방법을 살펴봅시다. 다음은 매우 간단한 `mapWith` 함수를 다시 살펴봅시다:

```js
const mapWith = (fn, [first, ...rest]) =>
  first === undefined
    ? []
    : [fn(first), ...mapWith(fn, rest)];

mapWith((x) => x * x, [1, 2, 3, 4, 5])
  //=> [1,4,9,16,25]
```

실행 과정을 단계별로 살펴봅시다. 먼저 `mapWith((x) => x * x, [1, 2, 3, 4, 5])`가 호출됩니다. 첫 번째`는 `정의되지 않은`이 아니므로 [fn(first), ...mapWith(fn, rest)]를 평가합니다. 그러기 위해서는 `fn(first)`와 `mapWith(fn, rest)`를 평가한 다음 `[fn(first), ...mapWith(fn, rest)]`를 평가해야 합니다.

이것은 대략 다음과 같이 작성하는 것과 같습니다:

```js
const mapWith = function (fn, [first, ...rest]) {
  if (first === undefined) {
    return [];
  }
  else {
    const _temp1 = fn(first),
          _temp2 = mapWith(fn, rest),
          _temp3 = [_temp1, ..._temp2];

    return _temp3;
  }
}
```
자바스크립트는 `mapWith(fn, rest)`를 평가하는 동안 `first` 또는 `fn(first)` 값과 일부 하우스키핑 정보를 유지해야 결과가 있을 때 `mapWith(fn, rest)`로 무엇을 할지를 기억할 수 있다는 점에 유의하세요. 자바스크립트는 `first`를 버릴 수 없습니다. 따라서 자바스크립트가 `1`에 매달릴 것임을 알 수 있습니다.

다음으로 자바스크립트는 `mapWith(fn, rest)`를 호출하는데, 이는 의미론적으로 `mapWith((x) => x * x, [2, 3, 4, 5])`와 동등합니다. 그리고 같은 일이 일어납니다:   
자바스크립트는 `2`(또는 `4`, 또는 구현에 따라 둘 다)에 매달려 있어야 하고, 그 값으로 무엇을 해야 할지 기억하기 위해 몇 가지 하우스키핑 정보를 추가해야 하며, `mapWith((x) => x * x, [3, 4, 5])`와 동등한 것을 호출합니다.

이런 일이 계속 일어나서 자바스크립트는 `mapWith((x) => x * x, [])`를 호출할 때까지 `1`, `2`, `3`, `4`, `5` 값과 하우스키핑 정보를 수집합니다. 결과 배열을 조립하기 시작하고 저장 중인 정보를 버리기 시작할 수 있습니다.

이 정보는 *콜 스택*에 저장되는데, 이 스택은 상당히 비쌉니다. 또한 배열의 길이를 두 배로 늘리면 스택에 필요한 공간이 두 배로 늘어나고 각 호출에 대한 하우스키핑 데이터(이를 *콜 프레임*이라고 하며 함수가 호출된 장소, 환경 등을 포함합니다)를 설정하고 해제하는 데 필요한 모든 작업도 두 배로 늘어납니다.

실제로 배열에 약 50개 이상의 항목이 있는 경우 이와 같은 방법을 사용하면 일부 구현이 매우 느리게 실행되거나 메모리가 부족하여 멈추거나 오류가 발생할 수 있습니다.

```js
mapWith((x) => x * x, [
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
  10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
  20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
  40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
  50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
  70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
  10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
  20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
  40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
  50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
  70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99
])
  //=> ???
```

더 좋은 방법이 있나요? 네, 있습니다. 사실 더 좋은 방법이 몇 가지 있습니다. 알고리즘을 더 빠르게 만드는 것은 컴퓨터 과학에서 매우 많이 연구되는 분야입니다. 여기서 살펴볼 방법은 *테일 콜 최적화* 또는 “TCO”라고 합니다.

### tail-call optimization

“꼬리 호출"은 한 함수의 마지막 동작이 다른 함수를 호출한 다음 다른 함수가 반환하는 값을 반환하는 경우 발생합니다. 예를 들어 `maybe` 함수 데코레이터를 생각해 보세요:

```js
const maybe = (fn) =>
  function (...args) {
    if (args.length === 0) {
      return;
    }
    else {
      for (let arg of args) {
        if (arg == null) return;
      }
      return fn.apply(this, args);
    }
  }
```

이 함수가 반환하는 곳은 세 곳입니다. 처음 두 곳은 아무 것도 반환하지 않으므로 중요하지 않습니다. 하지만 세 번째는 `fn.apply(this, args)`입니다. 이것은 다른 함수를 호출하고 그 결과를 반환하기 때문에 꼬리 호출입니다. 이것은 흥미로운데, 인자로 무엇을 제공할지(`this`, `args`) 분류한 후 자바스크립트는 현재 스택 프레임에 있는 모든 것을 버릴 수 있기 때문입니다. 더 이상 작업을 수행하지 않을 것이므로 기존 스택 프레임을 버릴 수 있습니다.

그리고 실제로 그렇게 합니다: 스택 프레임을 버리고 '어쩌면' 래핑된 호출을 할 때 추가 메모리를 소비하지 않습니다. 이것은 자바스크립트의 매우 중요한 특징입니다: **함수가 꼬리 위치에서 호출하는 경우 자바스크립트는 함수 호출 오버헤드와 스택 공간을 최적화합니다**.

훌륭하지만 한 번 래핑하는 것은 큰 문제가 아닙니다. 언제 우리가 정말 신경 쓸까요? 이 `length` 구현을 고려해 보세요:

```js
const length = ([first, ...rest]) =>
  first === undefined
    ? 0
    : 1 + length(rest);
```

`길이` 함수는 스스로를 호출하지만 `길이(나머지)`가 아닌 `1 + 길이(나머지)`를 반환하기 때문에 꼬리 호출이 아닙니다.

'길이'는 두 가지 작업을 수행해야 하고 그 중 하나는 '길이'에 대한 재귀 호출에 있는 동안 다른 하나는 재귀 호출 이후에 발생하기 때문에 꼬리 위치에서 자신을 호출하지 않는다는 식으로 문제를 명확하게 설명할 수 있습니다.

확실한 해결책은?

### converting non-tail-calls to tail-calls(비-꼬리 호출을 꼬리 호출로 변환하기)

명백한 해결책은 `1 +` 작업을 `길이` 호출에 밀어 넣는 것입니다. 다음은 첫 번째 컷입니다:

```js
const lengthDelaysWork = ([first, ...rest], numberToBeAdded) =>
  first === undefined
    ? 0 + numberToBeAdded
    : lengthDelaysWork(rest, 1 + numberToBeAdded)

lengthDelaysWork(["foo", "bar", "baz"], 0)
  //=> 3
```

이 `lengthDelaysWork` 함수는 꼬리 위치에서 스스로를 호출합니다. 스스로를 호출하기 전에 `1 +` 작업을 수행하며, 끝 위치에 도달할 때쯤이면 답을 가지고 있습니다. 이제 어떻게 작동하는지 알았으니 `0 + numberToBeAdded` 비즈니스를 정리할 수 있습니다. 하지만 그렇게 하는 동안 0으로 호출하는 것을 기억하는 것은 성가신 일입니다. 이 문제를 해결해 봅시다:

```js
const lengthDelaysWork = ([first, ...rest], numberToBeAdded) =>
  first === undefined
    ? numberToBeAdded
    : lengthDelaysWork(rest, 1 + numberToBeAdded)

const length = (n) =>
  lengthDelaysWork(n, 0);
```

또는 부분 적용을 사용할 수도 있습니다:

```js
const callLast = (fn, ...args) =>
    (...remainingArgs) =>
      fn(...remainingArgs, ...args);

const length = callLast(lengthDelaysWork, 0);

length(["foo", "bar", "baz"])
  //=> 3
```

이 버전의 `length` 호출은 `lengthDelaysWork`를 사용하며, 자바스크립트는 문자열의 길이에 비례하여 메모리를 차지하지 않도록 최적화합니다. 이 기법은 `mapWith`와 함께 사용할 수 있습니다:

```js
const mapWithDelaysWork = (fn, [first, ...rest], prepend) =>
  first === undefined
    ? prepend
    : mapWithDelaysWork(fn, rest, [...prepend, fn(first)]);

const mapWith = callLast(mapWithDelaysWork, []);

mapWith((x) => x * x, [1, 2, 3, 4, 5])
  //=> [1,4,9,16,25]
```

엄청나게 큰 배열에도 사용할 수 있습니다:

```js
mapWith((x) => x * x, [
     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,
    10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
    20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
    30,   31,   32,   33,   34,   35,   36,   37,   38,   39,
    40,   41,   42,   43,   44,   45,   46,   47,   48,   49,
    50,   51,   52,   53,   54,   55,   56,   57,   58,   59,
    60,   61,   62,   63,   64,   65,   66,   67,   68,   69,
    70,   71,   72,   73,   74,   75,   76,   77,   78,   79,
    80,   81,   82,   83,   84,   85,   86,   87,   88,   89,
    90,   91,   92,   93,   94,   95,   96,   97,   98,   99,

  // ...

  2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989,
  2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999 ])

  //=> [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196, ...
```

훌륭합니다! 꼬리 호출이 아닌 모든 메모리 및 성능 오버헤드 없이 대규모 배열을 매핑할 수 있습니다. 꼬리 호출을 하지 않는 재귀 함수에서 꼬리 위치에서 자신을 호출하는 재귀 함수로의 기본적인 변환은 꼬리 호출 최적화를 통합하는 언어를 사용하는 프로그래머에게 있어 가장 기본적인 패턴입니다.

### factorials

재귀를 소개할 때 종종 팩토리 계산을 언급합니다:

>  수학에서 `n!`로 표시되는 음수가 아닌 정수 `n`의 계승은 `n`보다 작거나 같은 모든 양의 정수의 곱입니다. 예를 들어

```js
5! = 5  x  4  x  3  x  2  x  1 = 120.
```

양의 정수의 계승을 계산하는 나이브 함수는 정의에서 바로 이어집니다:

```js
const factorial = (n) =>
  n == 1
  ? n
  : n * factorial(n - 1);

factorial(1)
  //=> 1

factorial(5)
  //=> 120
```

이것은 수학적으로 우아하지만 계산적으로 [filigree]입니다.

[filigree]: https://en.wikipedia.org/wiki/Filigree

다시 한번 말하지만, 꼬리 재귀가 아니므로 호출할 때마다 스택을 저장해야 반환된 결과를 가져와 `n * 계승(n - 1)`을 계산할 수 있습니다. 동일한 변환을 수행하고 수행해야 할 작업을 전달할 수 있습니다:

```js
const factorialWithDelayedWork = (n, work) =>
  n === 1
  ? work
  : factorialWithDelayedWork(n - 1, n * work);

const factorial = (n) =>
  factorialWithDelayedWork(n, 1);
```

또는 부분 적용을 사용할 수도 있습니다:

```js
const callLast = (fn, ...args) =>
    (...remainingArgs) =>
      fn(...remainingArgs, ...args);

const factorial = callLast(factorialWithDelayedWork, 1);

factorial(1)
  //=> 1

factorial(5)
  //=> 120
```

이전과 마찬가지로 `factorialWithDelayedWork` 함수를 작성한 다음 부분 적용(`callLast`)을 사용하여 하나의 인수만 취하고 초기 작업 값을 제공하는 `factorial` 함수를 만들었습니다.

### 기본 인수

문제는 직접 작성할 수 있다는 것입니다:

```js
const factorial = (n, work) =>
  n === 1
  ? work
  : factorial(n - 1, n * work);

factorial(1, 1)
  //=> 1

factorial(5, 1)
  //=> 120
```

하지만 항상 `1` 매개 변수를 추가해야 하는 것은 끔찍한 일이며, `factorial` 함수를 사용하는 모든 사람이 꼬리 재귀 구현을 사용하고 있다는 것을 알아야 할 것입니다.

우리가 정말로 원하는 것은 바로 이것입니다: '팩토리얼(6)`과 같은 코드를 작성하고, 자바스크립트가 `팩토리얼(6, 1)`을 의미한다는 것을 자동으로 인식하도록 하고 싶습니다. 하지만 자바스크립트가 스스로를 호출할 때는 `인수(5, 6)`을 호출할 것이고, 이는 `인수(5, 1)`을 의미하지 않을 것입니다.

자바스크립트는 이 정확한 구문을 제공하며, 이를 *기본 인수*라고 하며 다음과 같이 보입니다:

```js
const factorial = (n, work = 1) =>
  n === 1
  ? work
  : factorial(n - 1, n * work);

factorial(1)
  //=> 1

factorial(6)
  //=> 720
```

매개변수 목록을 `(n, work = 1)=>`로 작성함으로써, 두 번째 매개변수가 제공되지 않으면 `work`가 `1`에 바인딩되도록 명시하고 있습니다. 다른 꼬리 재귀 함수에서도 비슷한 작업을 수행할 수 있습니다:

```js
const length = ([first, ...rest], numberToBeAdded = 0) =>
  first === undefined
    ? numberToBeAdded
    : length(rest, 1 + numberToBeAdded)

length(["foo", "bar", "baz"])
  //=> 3

const mapWith = (fn, [first, ...rest], prepend = []) =>
  first === undefined
    ? prepend
    : mapWith(fn, rest, [...prepend, fn(first)]);

mapWith((x) => x * x, [1, 2, 3, 4, 5])
  //=> [1,4,9,16,25]
```

이제 두 개의 함수를 사용할 필요가 없습니다. 기본 인수는 간결하고 읽기 쉽습니다.

### 기본값과 구조 분해

앞서 매개변수 구조 분해가 할당 구조 분해와 같은 방식으로 작동한다는 것을 살펴봤습니다. 이제 기본 매개변수 인수를 만들 수 있다는 것을 배웠습니다. 기본 구조 분해 할당을 만들 수 있을까요?

```js
const [first, second = "two"] = ["one"];

`${first} . ${second}`
  //=> "one . two"

const [first, second = "two"] = ["primus", "secundus"];

`${first} . ${second}`
  //=> "primus . secundus"
```

매우 유용한 점: 매개변수에 대한 기본값과 마찬가지로 어트리뷰션 디스트럭처링에도 기본값을 제공할 수 있습니다.
