## 상호작용하는 제너레이터 {#interactive-generators}

우리는 암묵적인 상태를 유지하는 반복자를 만들기 위해 제너레이터를 사용했습니다. 제너레이터를 재귀적으로 펼치거나 상태 기계를 구현하는 데 사용하는 방법을 보았습니다. 그러나 때로는 암묵적인 상태를 유지하는 함수를 만들어야 할 때가 있습니다. 간단한 예를 통해 상태를 유지할 수 있는 함수를 작성하는 방법을 살펴보겠습니다.

![Coffee and Chess](../../images/coffee-chess.jpg)

예를 들어, 게임에서의 이동을 생각해봅시다. 플레이어가 수행하는 움직임은 값의 스트림이며, 배열의 내용이 값의 스트림으로 간주될 수 있는 것과 마찬가지입니다. 하지만 이동 스트림을 반복하려면 게임이 종료되어 어떤 이동이 이루어졌는지 알아야 합니다.

간단한 예로 틱택토(또는 XO 게임[xo])를 살펴보겠습니다. (체스를 예제로 들면 좋겠지만, 이 장의 범위를 벗어날 수 있으므로 간단한 예를 사용합니다.) 공간을 절약하기 위해 회전 및 반사를 무시하고, 첫 번째 플레이어의 움직임을 스트림으로 모델링하겠습니다.

[xo]: https://en.wikipedia.org/wiki/naughts-and-crosses

첫 번째 플레이어는 항상 o가 되며, 그들은 항상 o로 번호가 매겨진 좌측 상단 코너에 말을 놓습니다.

     o |   |   
    ---+---+---
       |   |
    ---+---+---
       |   |

두 번째 플레이어에게는 반사를 무시할 경우 다섯 가지 가능한 이동이 있습니다.

     o | 1 | 2 
    ---+---+---
       | 4 | 5
    ---+---+---
       |   | 8
       
이동 `1`을 고려해 보겠습니다. 그러면 보드는 다음과 같습니다.

     o | x |   
    ---+---+---
       |   |
    ---+---+---
       |   |


우리는 항상 위치 `6`에 이동합니다.

     o | x |   
    ---+---+---
       |   |  
    ---+---+---
     o |   |  

이제 `x`에게는 여섯 가지 가능한 이동이 있지만, 사실상 두 가지 선택만 있습니다: `3`과 그 외의 모든 경우입니다.

     o | x | 2 
    ---+---+---
     3 | 4 | 5
    ---+---+---
     o | 7 | 8
     
이동 `2`, `4`, `5`, `7`, 또는 `8`의 경우, 우리는 `3`에 이동하고 승리합니다. 그러나 `x`가 `3`에 이동하면 우리는 `8`에 이동합니다.


     o | x |   
    ---+---+---
     x |   |  
    ---+---+---
     o |   | o
     
이제 `x`에게 중요한 세 가지 이동이 있습니다: `4`, `7`, 그리고 그 외의 모든 경우입니다.

     o | x | 2 
    ---+---+---
     x | 4 | 5
    ---+---+---
     x | 7 | 8
     
`x`가 `4`에 이동하면, 우리는 `7`에 이동하고 승리합니다. `x`가 그 외의 곳에 이동하거나 `7`에 이동하면, 우리는 `4`에 이동하여 승리합니다.


### 틱택토를 무상태 함수로 표현하기

우리는 틱택토를 무상태 함수로 표현할 수 있습니다. 보드의 각 위치를 어떤 방식으로든 인코딩한 후, 위치에서 이동으로의 사전을 만듭니다. 예를 들어, 다음 위치에 대한 항목은 `8`이 됩니다.

     o | x |   
    ---+---+---
     x |   |  
    ---+---+---
     o |   |  
     
그 결과 보드는 다음과 같이 됩니다.

     o | x |   
    ---+---+---
     x |   |  
    ---+---+---
     o |   | o
     
또 다른 위치:

     o | x |   
    ---+---+---
       | x |  
    ---+---+---
     o |   |  
     
여기서는 3이 되며, 보드는 다음과 같이 됩니다.

     o | x |   
    ---+---+---
     o | x |  
    ---+---+---
     o |   |  
     
보드를 여러 가지 방식으로 인코딩할 수 있습니다. 여기에서 작성한 것처럼 멀티라인 문자열을 사용하여 포맷할 수도 있지만, 표현과 모델링을 결합하는 것은 바람직하지 않은 설계입니다. 우리의 함수는 테이블을 사용하는 DOM 게임이나 캔버스를 사용하는 브라우저 게임뿐만 아니라 텔레타입에서도 유용해야 합니다.

그래서 배열을 사용해보겠습니다. 예를 들어, 다음과 같은 보드는:

     o | x |   
    ---+---+---
       |   |  
    ---+---+---
       |   |  

다음과 같이 표현됩니다.

```js
[
  'o', 'x', ' ',
  ' ', ' ', ' ',
  ' ', ' ', ' '
]
```

그리고 다음 보드는:

     o | x |   
    ---+---+---
     x |   |  
    ---+---+---
     o |   |  
     
다음과 같이 표현됩니다.

```js
[
  'o', 'x', ' ',
  'x', ' ', ' ',
  'o', ' ', ' '
]
```

이제 위치에서 이동으로의 맵을 만들기 위해 POJO를 사용할 수 있습니다. `[]` 표기법을 키에 사용하여 어떤 표현식이든 키로 사용할 수 있으며, JavaScript가 이를 문자열로 변환합니다. 다음과 같이 작성할 수 있습니다.

```js
const moveLookupTable = {
  [[
    ' ', ' ', ' ',
    ' ', ' ', ' ',
    ' ', ' ', ' '
  ]]: 0,
  [[
    'o', 'x', ' ',
    ' ', ' ', ' ',
    ' ', ' ', ' '
  ]]: 6,
  [[
    'o', 'x', 'x',
    ' ', ' ', ' ',
    'o', ' ', ' '
  ]]: 3,
  [[
    'o', 'x', ' ',
    'x', ' ', ' ',
    'o', ' ', ' '
  ]]: 8,
  [[
    'o', 'x', ' ',
    ' ', 'x', ' ',
    'o', ' ', ' '
  ]]: 3,
  [[
    'o', 'x', ' ',
    ' ', ' ', 'x',
    'o', ' ', ' '
  ]]: 3,
  [[
    'o', 'x', ' ',
    ' ', ' ', ' ',
    'o', 'x', ' '
  ]]: 3,
  [[
    'o', 'x', ' ',
    ' ', ' ', ' ',
    'o', ' ', 'x'
  ]]: 3
  
  // ...
};
```

We get:

```js
{
  "o,x, , , , , , , ":6,
  "o,x,x, , , ,o, , ":3,
  "o,x, ,x, , ,o, , ":8,
  "o,x, , ,x, ,o, , ":3,
  "o,x, , , ,x,o, , ":3,
  "o,x, , , , ,o,x, ":3,
  "o,x, , , , ,o, ,x":3
}
```

그리고 이동을 찾아보고자 한다면 다음과 같이 작성할 수 있습니다.

```js
moveLookupTable[[
  'o', 'x', ' ',
  ' ', ' ', ' ',
  'o', 'x', ' '
]]
  //=> 3
```

그리고 거기에서 잡다한 일을 하는 무상태 함수는 간단합니다.

```js
statelessNaughtsAndCrosses([
  'o', 'x', ' ',
  ' ', ' ', ' ',
  'o', 'x', ' '
])
  //=> 3
```

### 상태를 가지는 함수로서의 틱택토(naughts and crosses) 표현

우리의 `statelessNaughtsAndCrosses` 함수는 게임의 상태 추적 작업을 우리, 즉 플레이어에게 미룹니다. 그렇다면 함수를 통해서 교대로 수를 주고받을 수 있다면 어떨까요? 그러려면 상태를 가지는 함수가 필요합니다. 우리의 "API"는 다음과 같이 작동할 것입니다: 새로운 게임을 시작하고 싶을 때는 함수를 호출하여 게임 함수를 반환받습니다. 그런 다음 이 게임 함수를 반복적으로 호출하며 우리의 수를 전달하고, 상대방의 수를 받을 수 있게 됩니다.

Something like this:

```js
const aNaughtsAndCrossesGame = statefulNaughtsAndCrosses();

// our opponent makes the first move
aNaughtsAndCrossesGame()
  //=> 0
  
// then we move, and get its next move back
aNaughtsAndCrossesGame(1)
  //=> 6
  
// then we move, and get its next move back
aNaughtsAndCrossesGame(4)
  //=> 3
```

우리는 이 기능을 `statelessNaughtsAndCrosses` 함수로부터 만들어낼 수 있습니다:


```js
const statefulNaughtsAndCrosses = () => {
  const state = [
    ' ', ' ', ' ',
    ' ', ' ', ' ',
    ' ', ' ', ' '
  ];
  
  return (x = false) => {
    if (x) {
      if (state[x] === ' ') {
        state[x] = 'x';
      }
      else throw "occupied!"
    }
    let o = moveLookupTable[state];
    state[o] = 'o';
    return o;
  }
};

const aNaughtsAndCrossesGame = statefulNaughtsAndCrosses();

// our opponent makes the first move
aNaughtsAndCrossesGame()
  //=> 0
  
// then we move, and get its next move back
aNaughtsAndCrossesGame(1)
  //=> 6
  
// then we move, and get its next move back
aNaughtsAndCrossesGame(4)
  //=> 3
```

지금까지 한 작업을 요약해봅시다: 우리는 상태를 가지는 함수를 만들었지만, 상태를 업데이트하는 함수를 감싸서 상태를 추적하게 만들었습니다. 상태는 전적으로 데이터에 인코딩되어 있습니다.

## #익숙한 것처럼 보인다

Generators를 살펴봤을 때, 일부 반복자는 본질적으로 상태를 가지지만, 때로는 이를 완전히 상태가 없는 방식으로 표현하는 것이 불편할 때가 있다고 했습니다. 때로는 JavaScript의 제어 흐름에 자연스럽게 암묵적으로 표현되는 상태 기계가 있으며, 이를 명시적으로 데이터로 표현하기보다는 제어 흐름으로 표현하는 것이 더 적합할 수 있습니다.

틱택토 게임에서도 거의 똑같은 작업을 수행했습니다. 이 게임은 완전히 상태 기계로 볼 수 있으며, 이 상태를 조회 테이블에 명시적으로 인코딩했습니다. 그렇다면 이러한 상태를 JavaScript 제어 흐름에 암묵적으로 인코딩할 수 있는 방법이 있을까요?

만약 우리가 상호작용을 완전히 제어할 수 있다면, 조회 테이블 대신 결정 트리(decision tree)로 게임 플레이를 인코딩하는 것이 더 쉬울 것입니다. 예를 들어 브라우저에서는 다음과 같이 할 수 있습니다:

```js
function browserNaughtsAndCrosses () {
  const x1 = parseInt(prompt('o plays 0, where does x play?'));
  switch (x1) {
    
    case 1:
      const x2 = parseInt(prompt('o plays 6, where does x play?'));
      switch (x2) {
        
        case 2:
        case 4:
        case 5:
        case 7:
        case 8:
          alert('o plays 3');
          break;
        
        case 3:
          const x3 = parseInt(prompt('o plays 8, where does x play?'));
          switch (x3) {
            
            case 2:
            case 5:
            case 7:
              alert('o plays 4');
              break;
              
            case 4:
              alert('o plays 7');
              break;
          }
      }
      break;
    
    // ...
  }
}
```

틱택토 게임은 단순하기 때문에 조회 함수가 훨씬 간단해 보이며, 특히 트리를 직선 코드로 표현하는 것이 잘 맞지 않는다는 점도 있습니다. 하지만 우리가 원한다면 프로그램의 상태를 결정 트리에서 암묵적으로 표현할 수 있다는 점은 분명히 보입니다.


그러나 우리의 솔루션은 제어를 반전시킵니다. 우리는 수를 두는 함수에 수를 전달하는 것이 아니라, 함수가 우리에게 호출을 합니다. 반복자와 함께, `function *`를 사용하여 제너레이터 함수를 작성하고, `yield`를 사용하여 제너레이터의 제어 흐름의 암묵적 상태를 유지하면서 값을 반환했습니다.

여기서도 동일한 작업을 수행할 수 있을까요? 처음엔 불가능해 보일 수 있습니다. 제너레이터 함수에 플레이어의 수를 전달하는 방법은 어떻게 할까요? 하지만 이 첫인상은 실제로 우리가 지금까지 본 것만 볼 수 있다는 점에서 착각입니다. 실제로는 어떻게 작동하는지 살펴봅시다.

### 상호작용하는 제너레이터

지금까지 우리는 `.next()`로 반복자(및 제너레이터)를 호출했습니다. 그런데 `.next()`에 값을 전달한다면 어떻게 될까요? 만약 가능하다면, 제너레이터 함수가 틱택토를 플레이하는 방법은 다음과 같습니다:

가능하다면, 어떻게 작동할까요?

```js
function* generatorNaughtsAndCrosses () {
  const x1 = yield 0;
  switch (x1) {
    
    case 1:
      const x2 = yield 6;
      switch (x2) {
        
        case 2:
        case 4:
        case 5:
        case 7:
        case 8:
          yield 3;
          break;
        
        case 3:
          const x3 = yield 8;
          switch (x3) {
            
            case 2:
            case 5:
            case 7:
              yield 4;
              break;
              
            case 4:
              yield 7;
              break;
          }
      }
      break;
    
    // ...
  }
}

const aNaughtsAndCrossesGame = generatorNaughtsAndCrosses();
```

우리는 먼저 `.next()`를 호출하여 첫 수를 얻습니다. 그 이후에는 `.next(...)`를 호출하고, 우리의 수를 전달합니다(가장 처음 호출할 때는 제너레이터가 시작되지 않았기 때문에 인수를 전달하지 않고 `.next()`를 호출해야 합니다. 제너레이터가 시작되기 전에 어떤 상태를 전달하고 싶다면, 이를 매개변수로 전달합니다.):


```js
aNaughtsAndCrossesGame.next().value
  //=> 0
  
aNaughtsAndCrossesGame.next(1).value
  //=> 6
  
aNaughtsAndCrossesGame.next(3).value
  //=> 8
  
aNaughtsAndCrossesGame.next(7).value
  //=> 4  
```

우리의 제너레이터 함수는 제어 흐름의 암묵적 상태를 유지하면서 상태를 유지하지만, 우리가 호출하는 반복자를 반환합니다. 이 반복자는 우리를 호출하지 않습니다. 또한 이를 컬렉션으로 사용할 수 없으며, `for...of` 블록에서 매개변수로 확장하거나 주제로 사용하는 것은 의미가 없습니다.


하지만 제너레이터 함수는 암묵적으로 상태를 유지할 수 있도록 해줍니다. 그리고 때로는 데이터에 명시적으로 상태를 저장하기보다는 암묵적으로 상태를 사용하고자 할 때가 있습니다.


### 요약

우리는 상태가 제어 흐름에 암묵적으로 모델링된 정적 컬렉션의 반복자를 만드는 방법으로 제너레이터를 살펴보았습니다. 그러나 여기서 보았듯이 제너레이터는 상호작용적으로 사용할 수도 있으며, 값을 전달하고 값을 반환받는 방식으로 일반 함수처럼 사용할 수도 있습니다.


다시 말해, 중요한 차이점은 "상호작용" 제너레이터가 상태를 가지며, 그 상태는 제어 흐름에 구현되어 있다는 점입니다.
