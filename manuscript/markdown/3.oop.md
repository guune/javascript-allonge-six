# 커피 공장: "객체 지향 프로그래밍"


객체와 클래스를 사용한 프로그래밍은 1960년대 후반 노르웨이에서 Simula [Simula] 프로그래밍 언어와 함께 시작되었습니다. 이 언어의 창시자인 올레-요한 달(Ole-Johan Dahl)과 크리스텐 니가르드(Kristen Nygaard)는 결국 컴퓨팅에서 지배적인 패러다임이 될 것이라고 여겨지는 개념을 설명하기 위해 그 단어들을 사용하지 않았습니다.

10년 후, 앨런 케이 박사는 "객체 지향 프로그래밍"이라는 용어를 만들어냈고, Smalltalk [Smalltalk] 프로그래밍 언어를 공동 개발했습니다. 그는 "OOP"가 객체들이 서로 메시지를 사용해 통신하는 것이라고 말하며, 다른 언어들이 Smalltalk에서 중요하지 않은 것들만 모방하고, 그가 중요하게 생각하는 것들은 무시했다고 유명하게 이야기했습니다.

[Simula]: https://en.wikipedia.org/wiki/Simula
[Smalltalk]: https://en.wikipedia.org/wiki/Smalltalk

그 이후로 언어들은 기존 패러다임 위에 객체 같은 개념을 덧붙이거나(Object Pascal [Object Pascal]과 OCaml [OCaml]처럼), 다른 패러다임과 함께 엮거나(자바스크립트처럼), 아니면 객체를 전적으로 수용해왔습니다.

[Object Pascal]: https://en.wikipedia.org/wiki/Object_Pascal
[OCaml]: https://en.wikipedia.org/wiki/OCaml
[C++]: https://en.wikipedia.org/wiki/C%2B%2B

그렇긴 하지만, "객체 지향"에 대한 단일한 정의는 존재하지 않습니다. 한 가지 이유는 "객체"에 대한 단일한 정의가 없기 때문입니다.

### objects

Smalltalk과 Ruby [Ruby]같은 언어들은 객체를 완전히 캡슐화된 엔티티로 다룹니다. 객체의 개인 상태에 접근할 수 없으며, 할 수 있는 것은 단지 그 메서드를 호출하는 것뿐입니다. 반면에 Java와 같은 언어들은 객체가 서로의 상태에 접근할 수 있게 허용합니다.

[Ruby]: https://en.wikipedia.org/wiki/Ruby_(programming_language)

일부 언어(예: Java)는 매우 엄격한 객체와 클래스를 가지고 있어, 런타임에 객체에 새 메서드나 속성을 추가하는 것이 불가능하거나 불편합니다. 일부 언어는 런타임에 메서드와 속성을 추가하는 데 유연합니다. 또 다른 언어들은 객체를 사전과 같이 취급하여, 속성과 심지어 메서드를 마음대로 추가하거나 수정하거나 제거할 수 있습니다.

이렇게 보면 "객체"라는 개념은 언어에 따라 유연하다는 것을 알 수 있습니다.

### 클래

"클래스" 개념도 언어마다 유연합니다. 객체 지향 언어들은 클래스가 필요한지, 그리고 클래스가 어떻게 작동하는지에 대해 일관된 합의를 하지 않습니다. 예를 들어, 공통 리스프 객체 시스템(Common Lisp Object System)은 클래스로 행동을 정의하고, 일반 함수로도 행동을 정의합니다. Self [Self]와 NewtonScript [NewtonScript] 언어는 클래스 대신 프로토타입을 사용합니다.

따라서 일부 "객체 지향" 언어는 객체는 있지만 클래스는 없습니다.

[Self]: https://en.wikipedia.org/wiki/Self_(programming_language)
[NewtonScript]: https://en.wikipedia.org/wiki/NewtonScript

C++는 클래스를 가지고 있지만, 이는 "일급 객체"가 아닙니다. 클래스를 변수에 할당하거나 함수에 전달할 수 없습니다. 하지만 클래스의 생성자, 즉 새로운 객체를 만드는 함수를 조작할 수 있습니다. 그러나 이미 생성된 객체의 행동을 변경하기 위해 그 생성자를 조작할 수는 없습니다. 인스턴스 행동은 기본적으로 초기 바인딩됩니다.

Ruby는 클래스를 가지고 있으며, 이들은 일급 객체입니다. 객체에 그 클래스 요청을 할 수 있고, 클래스를 변수에 넣거나 메서드에 전달하거나 메서드에서 반환할 수 있습니다. Ruby와 Smalltalk에서 클래스는 심지어 자신만의 클래스를 가지고 있으며, 이는 Class의 인스턴스입니다[^meta] 인스턴스 행동은 늦게 바인딩되고 확장할 수 있습니다.[^mp]

[^mp]: 기본 클래스를 확장하여 행동을 추가하는 행위는 논란의 여지가 있는 주제입니다

[^meta]: 클래스의 클래스가 Class라면, Class의 클래스는 무엇일까요? Ruby에서 Class.class == Class입니다. Smalltalk에서는 MetaClass로, 이는 클래스의 행동을 깊은 방식으로 변경할 수 있는 가능성을 열어줍니다.


### 생성자

일부 언어는 프로그램이 독립적으로 객체를 구성할 수 있도록 허용하고, 다른 언어(특히 클래스 중심인 언어들)는 객체가 항상 자신의 클래스에 의해 구성되어야 합니다. 일부 언어는 모든 함수나 메서드를 생성자로 사용할 수 있도록 허용하고, 다른 언어는 생성자를 위한 특별한 구문이나 선언이 필요합니다.

### prototypes are not classes

Self와 NewtonScript와 같은 프로토타입 언어들은 클래스를 전혀 사용하지 않고, 프로토타입을 사용하여 객체 집합의 공통 행동을 정의합니다. 프로토타입과 클래스의 차이는 모델 하우스와 주택 설계도 사이의 차이와 유사합니다.

예를 들어, 건축가에게 "그 모델 하우스와 똑같은 집을 만들어줘"라고 요청하면, 건축가는 모델 하우스와 많은 공통점을 가진 집을 만들어 줍니다. 그러고 나서 당신은 그 집을 추가적인 개인화로 장식합니다. 하지만 모델 하우스는 본질적으로 집입니다. 비어 있는 상태로 유지할 수 있지만, 원칙적으로 가족을 그 안으로 옮길 수 있습니다. 이는 건축가에게 설계도를 기반으로 집을 만들어 달라고 요청하는 것과 다릅니다. 설계도는 집의 특징을 지정할 수 있지만, 그것은 집이 아닙니다. 결코 집으로 사용될 수 없습니다.

프로토타입은 모델 하우스와 같고, 클래스는 설계도와 같습니다. 클래스는 그들이 설명하는 객체와 같지 않습니다.[^wellactually]

[^wellactually]: 사실, 프로토타입과 클래스의 차이는 모델 하우스와 설계도 사이의 차이와 같습니다. 하지만 프로토타입은 모델 하우스와 같지 않습니다. 실제로 객체와 그 프로토타입 간의 관계는 위임의 관계입니다. 따라서 모델 하우스에 부엌이 있다고 가정하고, 당신이 건축가에게 모델을 프로토타입으로 사용하여 집을 만들어 달라고 요청하면, 당신은 자신만의 부엌을 커스터마이즈할 수 있습니다. 그러나 당신이 자신만의 맞춤형 부엌을 원하지 않는다면, 모델 하우스의 부엌을 사용하여 요리를 할 것입니다. 모델 하우스와 집 간의 관계는 때때로 연결적 상속으로 설명되며, 자바스크립트도 그렇게 할 수 있습니다.  [concatenative inheritance](https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a)

### "객체 지향 프로그래밍"은 거의 모든 것을 의미할 수 있다

"객체 지향 프로그래밍"에 대한 이 whirlwind 투어를 통해, "객체 지향 프로그래밍"의 아이디어가 프로그래밍 언어의 역사에서 공통된 뿌리를 가지고 있지만, 각 언어가 자신의 특정한 방식으로 구현하고 있다는 것을 알 수 있습니다.

따라서 자바스크립트에서 "객체"와 "프로토타입", "클래스"에 대해 이야기할 때, 우리는 자바스크립트에서 구현된 객체, 프로토타입 및 클래스를 이야기하고 있습니다. 다른 언어는 이러한 아이디어에 대해 근본적으로 다른 관점을 가질 수 있다는 점을 유념해야 합니다.

### 자바스크립트 접근법

자바스크립트는 객체를 가지고 있으며, 기본적으로 이 객체는 사전(dictionary)입니다. 기본적으로 객체는 서로의 상태를 직접 조작합니다. 메서드는 런타임에 객체에 추가되거나 제거될 수 있습니다.

자바스크립트는 선택적 프로토타입을 지원합니다. 프로토타입은 모델 하우스와 같은 객체입니다.

자바스크립트에서 객체 및 배열 리터럴은 각각 표준 라이브러리의 객체 프로토타입 및 배열 프로토타입에 대한 행동을 위임하는 객체를 생성합니다. 자바스크립트는 또한 `Object.create`를 사용하여 프로토타입이 있거나 없는 객체를 구성할 수 있으며, `new`를 사용하여 생성자 함수를 사용하여 객체를 구성할 수 있습니다.

프로토타입과 생성자 함수를 사용하여 자바스크립트 프로그램은 다른 언어에서 클래스의 많은 기능을 에뮬레이션할 수 있습니다. 자바스크립트는 또한 생성자 함수와 프로토타입을 선언적 방식으로 작성하기 위한 문법 설탕(syntactic sugar)을 제공하는 class 키워드를 가지고 있습니다.

기본적으로, 자바스크립트 클래스는 객체와 관련된 프로토타입을 가진 생성자로 구성됩니다. 이는 `class` 키워드로 표시할 수 있으며, 함수의 기본 `.prototype` 속성을 다루거나 함수와 객체를 독립적으로 조합함으로써 표현할 수 있습니다.

자바스크립트 클래스는 생성자이지만, C++ 생성자보다 더 많은 기능을 가지고 있습니다. 왜냐하면 프로토타입을 조작함으로써 생성하는 인스턴스의 동작을 확장하거나 수정할 수 있기 때문입니다. 자바스크립트 클래스는 자바스크립트 객체가 객체 지향 프로그래밍(OOP)에 대해 미니멀리스트 접근을 취하는 것과 같은 방식으로 OOP에 대해 미니멀리스트 접근을 취합니다. 예를 들어, 동작은 객체, 프로토타입 또는 클래스로 혼합할 수 있으며, 이는 모두 확장이 가능한 객체이기 때문에 동일한 메커니즘을 사용합니다.

결론적으로, 자바스크립트는 다른 객체 지향 프로그래밍 언어와 정확히 같지 않으며, 그 클래스도 다른 클래스가 있는 언어와 같지 않습니다. 그러나 다른 객체 지향 프로그래밍 언어도 마찬가지로 서로 같지 않으며, 다른 클래스도 그렇습니다.

