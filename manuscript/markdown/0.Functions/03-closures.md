## 클로저와 스코프 {#closures}

함수 안의 함수가 어떻게 작동하는지 살펴볼 시간입니다:

    ((x) => (y) => x)(1)(2)
      //=> 1

먼저, 위에서 배운 내용을 사용해봅시다. (*어떤 함수*)(*어떤 인자*)가 주어졌을 때, 우리는 함수를 인자에 적용하고, 환경을 생성하며, 인자의 값을 이름에 바인딩하고, 함수의 표현식을 평가한다는 것을 알고 있습니다. 그래서 먼저 이 코드를 실행합니다:

    ((x) => (y) => x)(1)
      //=> [Function]

시그니처가 `(x) => ...`인 함수에 속한 환경은 `{x: 1, ...}`가 되고, 함수를 적용한 결과는 또 다른 함수값입니다. 결과값이 함수인 것이 이해가 되는데, `(x) => ...` 본문의 표현식이 다음과 같기 때문입니다:

    (y) => x

이제 우리는 그 함수를 나타내는 값을 가지고 있습니다. 그 다음에는 그 함수값을 인자 `2`에 적용할 것입니다:

      ((y) => x)(2)

그러면 새로운 환경 `{y: 2, ...}`를 얻게 됩니다. 그런데 이 함수의 환경에서 표현식 `x`는 어떻게 평가될까요? 이 환경에는 `x`가 없으니 다른 곳에서 와야 합니다.

> 이것이 바로 JavaScript와 같은 계열의 언어들이 가진 중요한 특징 중 하나입니다:   
> 함수가 다른 함수 안에 중첩될 수 있는지, 그리고 만약 그렇다면 함수 "외부"에서 정의된 변수들을 함수 내부에서 어떻게 다루는지 입니다.   
>  예를 들어, Ruby에서는 다음과 같이 작성합니다:   
```ruby
lambda { |x|
  lambda { |y| x }
}[1][2]
  #=> 1
```
이제 계속하기 전에 편안한 Allongé를 즐겨봅시다!


### 자유 변수가 없는 함수가 순수하다면, 클로저는 불순한가요?

`(y) => x` 함수는 흥미롭습니다. 이 함수는 *자유 변수* `x`를 포함하고 있습니다.[^nonlocal]   
자유 변수는 함수 내에서 바인딩되지 않은 변수를 말합니다. 지금까지 우리는 변수를 "바인딩"하는 한 가지 방법만 봤는데, 그것은 같은 이름의 인자를 전달하는 것이었습니다.    
`(y) => x` 함수는 `x`라는 이름의 인자를 가지고 있지 않으므로, 변수 `x`는 이 함수에서 바인딩되지 않았으며, 이는 `x`를 "자유"롭게 만듭니다.

[^nonlocal]: You may also hear the term "non-local variable." [Both are correct.](https://en.wikipedia.org/wiki/Free_variables_and_bound_variables) 

이제 함수에서 사용되는 변수가 바인딩되었거나 자유롭다는 것을 알았으니, 우리는 함수를 자유 변수가 있는 것과 없는 것으로 나눌 수 있습니다:

 * 자유 변수가 없는 함수를 *순수 함수*라고 합니다.
 * 하나 이상의 자유 변수를 포함하는 함수를 *클로저*라고 합니다.
  
순수 함수는 이해하기가 가장 쉽습니다. 어디서 사용하든 항상 같은 의미를 가집니다. 다음은 우리가 이미 본 몇 가지 순수 함수입니다:

    () => {}
    
    (x) => x
      
    (x) => (y) => x

첫 번째 함수는 변수가 전혀 없으므로 자유 변수도 없습니다. 두 번째 함수는 유일한 변수가 바인딩되어 있으므로 자유 변수가 없습니다. 세 번째 함수는 사실 두 개의 함수가 중첩된 것입니다. `(y) => ...`는 자유 변수를 가지고 있지만, 전체 표현식은 `(x) => ...`를 참조하며, 이것은 자유 변수를 가지고 있지 않습니다: 본문 어디에서나 유일한 변수는 `x`이고, 이는 확실히 `(x) => ...` 내에서 바인딩됩니다.

여기서 우리는 뭔가를 배웁니다: 순수 함수는 클로저를 포함할 수 있습니다.

> 순수 함수가 클로저를 포함할 수 있다면, 클로저가 순수 함수를 포함할 수 있을까요? 지금까지 배운 내용만 사용하여 순수 함수를 포함하는 클로저를 만들어보세요. 불가능하다면, 그 이유를 설명해보세요.

순수 함수는 모든 "입력"이 인자에 의해 완전히 정의되기 때문에 항상 같은 의미를 가집니다.   
하지만 클로저는 그렇지 않습니다. 만약 제가 이 순수 함수 `(x, y) => x + y`를 보여준다면, 우리는 `(2, 2)`와 함께 사용했을 때 정확히 무엇을 하는지 알 수 있습니다.    
하지만 이 클로저는 어떨까요: `(y) => x + y`? 자유 변수 `x`를 평가하는 마법을 이해하지 않고서는 인자 `(2)`와 함께 무엇을 할지 말할 수 없습니다.

### 항상 환경입니다

클로저가 어떻게 평가되는지 이해하기 위해서는 환경을 다시 살펴봐야 합니다. 이전에 말했듯이, 모든 함수는 환경과 연관되어 있습니다. 또한 우리는 환경을 설명할 때 뭔가를 대충 넘어갔습니다. `((x) => (y) => x)(1)`의 환경이 `{x: 1, ...}`이고 `((y) => x)(2)`의 환경이 `{y: 2, ...}`라고 했던 것을 기억하시나요? 이제 빈칸을 채워봅시다!

`((y) => x)(2)`의 실제 환경은 `{y: 2, '..': {x: 1, ...}}`입니다. '..'는 "부모" 또는 "감싸는 환경" 또는 "상위 환경"과 같은 의미입니다. 이것은 함수 `(y) => x`가 `(x) => ...`의 본문 안에 있기 때문에 `(x) => ...`의 환경입니다. 따라서 함수가 인자에 적용될 때마다 그 환경은 항상 부모 환경에 대한 참조를 가지고 있습니다.

이제 환경 `{y: 2, '..': {x: 1, ...}}`에서 `((y) => x)(2)`를 어떻게 평가하는지 추측할 수 있습니다. 변수 `x`는 `(y) => ...`의 직접적인 환경에는 없지만 부모 환경에는 있으므로, `1`로 평가되고 이것이 `((y) => x)(2)`가 자신의 인자를 무시하고 반환하는 값입니다.

> `(x) => x`는 I 컴비네이터 또는 *항등 함수*라고 합니다. `(x) => (y) => x`는 K 컴비네이터 또는 Kestrel이라고 합니다. 어떤 사람들은 이것에 너무 흥분해서 책을 쓰기도 하는데, 일부는 [mock], 일부는 - 어떻게 표현해야 할까요 - Ruby를 사용한다면 [interesting].

[mock]: http://www.amzn.com/0192801422?tag=raganwald001-20
[interesting]: https://leanpub.com/combinators "Kestrels, Quirky Birds, and Hopeless Egocentricity"

함수는 조부모도 가질 수 있습니다:

    (x) =>
       (y) =>
         (z) => x + y + z

이 함수는 다음과 거의 같은 일을 합니다:

    (x, y, z) => x + y + z
    
다만 `(1, 2, 3)` 대신 `(1)(2)(3)`으로 호출한다는 차이가 있습니다. 또 다른 큰 차이점은 `(1)`로 호출하고 나중에 `(2)(3)`으로 호출할 수 있는 함수를 받을 수 있다는 것입니다.

> 첫 번째 함수는 두 번째 함수를 [currying]한 결과입니다. 커링된 함수를 일부 인자만으로 호출하는 것을 때때로 [partial application]이라고 합니다. 일부 프로그래밍 언어는 함수를 수동으로 중첩할 필요 없이 자동으로 커링하고 부분적으로 평가합니다.

[currying]: https://en.wikipedia.org/wiki/Currying
[partial application]: https://en.wikipedia.org/wiki/Partial_application

### 그림자 같은 행성에서 온 그림자 같은 변수들

조상 환경의 변수와 같은 이름을 가진 변수가 있을 때 흥미로운 일이 발생합니다. 다음을 고려해보세요:

    (x) =>
      (x, y) => x + y

함수 `(x, y) => x + y`는 순수 함수입니다. 왜냐하면 `x`가 자신의 환경 내에서 정의되어 있기 때문입니다. 부모도 `x`를 정의하고 있지만, `x + y`를 평가할 때는 무시됩니다. JavaScript는 항상 함수 자신의 환경에서 시작하여 바인딩을 찾고, 찾을 때까지 각 부모를 차례로 검색합니다. 다음의 경우도 마찬가지입니다:

    (x) =>
      (x, y) =>
        (w, z) =>
          (w) =>
            x + y + z

`x + y + z`를 평가할 때, JavaScript는 증조부모 스코프에서 `x`와 `y`를 찾고 부모 스코프에서 `z`를 찾을 것입니다. 고조부모 스코프의 `x`는 무시되며, 두 개의 `w`도 마찬가지입니다. 변수가 조상 환경의 바인딩과 같은 이름을 가질 때, 이를 조상을 *가린다(shadow)*고 합니다.

이것은 종종 좋은 것입니다.

### 닭이 먼저일까요, 달걀이 먼저일까요?

순수 함수와 클로저의 이러한 동작은 소프트웨어를 작성하는 데 활용할 수 있는 많은, 많은 결과를 가져옵니다. 우리는 변수와 가변 상태를 다루기 위해 JavaScript가 제공하는 다른 메커니즘들과 함께 이것들을 자세히 살펴볼 것입니다.

하지만 그전에 마지막 질문이 하나 있습니다: 조상은 어디서부터 시작될까요? 파일에 다른 코드가 없다면, `(x) => x`의 부모 환경은 무엇일까요?

JavaScript는 항상 우리가 제어할 수 없는 최소한 하나의 환경을 가지고 있습니다: 표준 함수들이 가득한 라이브러리와 같은 유용한 것들이 바인딩된 전역 환경입니다. 따라서 REPL에서 `((x) => x)(1)`을 호출할 때, 전체 환경은 다음과 같이 보일 것입니다: `{x: 1, '..': 전역 환경}`.

때때로 프로그래머들은 이것을 피하고 싶어합니다. 코드가 전역 환경에서 직접 작동하는 것을 원하지 않는다면 어떻게 할 수 있을까요? 물론 환경을 만들면 됩니다. 많은 프로그래머들은 모든 JavaScript 파일을 다음과 같이 작성하기를 선택합니다:

    // top of the file
    (() => {
      
      // ... lots of JavaScript ...
      
    })();
    // bottom of the file

이것의 효과는 전역 환경과 여러분의 함수들 사이에 새로운 빈 환경을 삽입하는 것입니다: {x: 1, '..': {'..': global environment}}. 가변 상태를 논의할 때 보게 되겠지만, 이는 프로그래머가 프로그램의 모든 코드가 공유하는 전역 상태를 실수로 변경하는 것을 방지하는 데 도움이 됩니다.
