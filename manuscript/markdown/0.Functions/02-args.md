## 아, 논쟁을 하고 싶군요[^mp] {#fargs}

[^mp]: [The Argument Sketch](http://www.mindspring.com/~mfpatton/sketch.htm) "Monty Python's Previous Record"와 "Monty Python's Instant Record Collection"에서 나온 The Argument Sketch ↩

지금까지 우리는 인자가 없는 함수들을 살펴보았습니다. 우리는 인자가 무엇인지조차 설명하지 않았고, 단지 우리의 함수들에는 인자가 없다는 것만 언급했습니다.

A> 대부분의 프로그래머들은 인자(종종 "매개변수"라고도 불림)에 매우 익숙합니다. 중등 교육과정의 수학에서도 이를 다룹니다. 그래서 여러분은 이것이 무엇인지 알고 있고, 저는 여러분이 알고 있다는 것을 알지만, 설명에 대해 조금만 인내심을 가져주세요!

인자가 있는 함수를 만들어봅시다:

    (room) => {}

이 함수는 `room`이라는 하나의 인자를 가지고 있으며, 함수 본문은 비어있습니다.   
다음은 두 개의 인자를 가진 함수이며 역시 본문은 비어있습니다:

    (room, board) => {}

이 함수가 `room`과 `board` 두 개의 인자를 가지고 있다는 것은 아마 충분히 이해하실 것입니다. 인자로 무엇을 할 수 있을까요? 당연히 함수 본문에서 사용하는 것입니다. 다음은 무엇일까요?

    (diameter) => diameter * 3.14159265
    
이것은 지름이 주어졌을 때 원의 둘레를 계산하는 함수입니다. 저는 이것을 "지름을 나타내는 값에 적용했을 때, 이 함수는 지름에 3.14159265를 곱한 값을 반환한다"라고 설명합니다.

인자가 없는 함수를 적용할 때는 `(() => {})()` 와 같이 작성했다는 것을 기억하세요. 인자가 있는 함수를 적용할 때는 괄호 안에 인자(들)를 넣습니다:

    ((diameter) => diameter * 3.14159265)(2)
      //=> 6.2831853

두 개의 인자를 가진 함수를 작성하고 적용하는 방법도 놀랍지 않을 것입니다:

    ((room, board) => room + board)(800, 150)
      //=> 950

### 함수와 본문에 대한 간단한 요약

본문의 표현식에서 인자가 어떻게 사용되는지는 예제를 통해 아마 완벽히 이해하셨을 것입니다. 특히 이전에 프로그래밍 언어를 사용해보셨다면 더욱 그럴 것입니다(제가 중학교 때 배웠던 BASIC 방언은 프로시저를 호출할 때 매개변수를 허용하지 않았던 것으로 기억합니다만, 그것은 예외입니다).

표현식은 값의 표현(예: 3.14159265, true, undefined), 표현식을 결합하는 연산자(예: 3 + 2), 배열을 만드는 [1, 2, 3]과 같은 특별한 형식, 또는 함수를 만드는 function (인자들) {본문-구문들}로 구성됩니다.

중요한 가능한 구문 중 하나는 return 구문입니다. return 구문은 유효한 JavaScript 표현식이라면 무엇이든 받아들일 수 있습니다.

이 느슨한 정의는 재귀적이므로, 함수가 표현식을 포함한 return 구문을 포함할 수 있다는 것을 직관적으로 알 수 있습니다(또는 다른 언어 경험을 통해). 따라서 함수를 반환하는 함수나, 다른 배열 표현식을 포함하는 배열, 또는 배열을 반환하는 함수, 함수들의 배열, 함수들의 배열을 반환하는 함수 등을 작성할 수 있습니다.

```js
() => () => {};

() => [ 1, 2, 3];

[1, [2, 3], 4];

() => [
    () => 1,
    () => 2,
    () => 3
  ];
```

### 값에 의한 호출  {#call-by-value}

대부분의 현대 프로그래밍 언어처럼, JavaScript는 "값에 의한 호출" 평가 전략을 사용합니다. [evaluation strategy].이는 함수를 표현식이나 표현식들에 적용하는 코드를 작성할 때, JavaScript가 먼저 모든 표현식을 평가하고 그 결과값(들)에 함수를 적용한다는 의미입니다.

[evaluation strategy]: http://en.wikipedia.org/wiki/Evaluation_strategy

따라서 다음과 같이 작성할 때:

    ((diameter) => diameter * 3.14159265)(1 + 1)
      //=> 6.2831853

내부적으로 일어나는 일은 먼저 `1 + 1` 표현식이 평가되어 `2`가 되고, 그 다음 우리의 원주 함수가 `2`에 적용됩니다[^f2f]

[^f2f]: 우리는 함수를 표현식에 적용할 수 없다고 말했습니다. 하지만 하나 이상의 함수에는 함수를 적용할 수 있습니다. 함수도 값이니까요! 이는 흥미로운 응용이 있으며, 함수에 적용되는 함수 섹션에서 더 자세히 다룰 것입니다.[Functions That Are Applied to Functions](#consumers).

JavaScript가 항상 값에 의한 호출을 사용하지만, "값"이라는 개념에는 추가적인 미묘함이 있다는 것을 아래에서 살펴볼 것입니다. 하지만 그전에, 변수에 대해 살펴보겠습니다.

### 변수와 바인딩

지금까지는 모든 것이 단순하고 직관적으로 보입니다. 이제 인자에 대해 더 자세히 이야기해보겠습니다. 우리는 `(diameter) => diameter * 3.14159265`에서 시작하여 다음과 같은 함수까지 살펴볼 것입니다:

    (x) => (y) => x

A> `(x) => (y) => x`는 마치 영어를 제2외국어로 배우는데 선생님이 곧 *antidisestablishmentarianism(반국교제도주의)*같은 단어를 사용하게 될 거라고 약속하는 것처럼 이상해 보입니다. 인상적으로 보이기 위해 긴 단어를 사용하고 싶은 욕구 외에는, 19세기 영국 정치에서 영국 국교회의 역할을 논의하고 싶어질 때까지는 매력적으로 보이지 않을 것입니다.   

A> 하지만 *antidisestablishmentarianism*이라는 단어를 배우는 데는 또 다른 이유가 있습니다: 영어 문법에서 접두사와 접미사가 어떻게 작동하는지 배울 수 있습니다. `(x) => (y) => x`도 마찬가지입니다. 그 자체로 중요한 의미가 있을 뿐만 아니라, 함수를 만드는 함수, 환경, 변수 등에 대해 배우기에 좋은 예시이기도 합니다.   

이것이 어떻게 작동하는지 이야기하기 위해, 몇 가지 용어에 대해 합의해야 합니다(이미 알고 계실 수도 있지만, 함께 확인하고 "사전을 동기화"해봅시다). `(x) => ...`에서 첫 번째 `x`는 인자입니다. `function (y) ...`에서 `y`도 또 다른 인자입니다. `=> x`에서 두 번째 `x`는 인자가 아니라, 변수를 참조하는 표현식입니다. 인자와 변수는 `(x) => (y) => x`나 단순한 `(x) => x`에서나 같은 방식으로 작동합니다.

함수가 호출될 때마다("호출"은 "0개 이상의 인자에 적용"을 의미합니다), 새로운 *환경*이 생성됩니다. 환경은 변수를 이름으로 값에 매핑하는 (비어있을 수도 있는) 사전입니다. "변수"라고 부르는 표현식의 `x`는 그 자체로 환경에서 값을 찾아 평가되는 표현식입니다.


값은 어떻게 환경에 들어가나요? 인자의 경우는 매우 간단합니다. 함수를 인자에 적용할 때, 각 인자에 대한 항목이 사전에 추가됩니다. 따라서 다음과 같이 작성할 때:

    ((x) => x)(2)
      //=> 2

다음과 같은 일이 일어납니다:

1. JavaScript는 이 전체를 여러 하위 표현식으로 구성된 하나의 표현식으로 파싱합니다.
2. 그런 다음 하위 표현식을 포함하여 표현식을 평가하기 시작합니다.
3. 하위 표현식 중 하나인 (x) => x는 함수로 평가됩니다.
4. 다른 하나인 2는 숫자 2로 평가됩니다.
5. JavaScript는 이제 함수를 인자 2에 적용하는 것을 평가합니다. 여기서부터 흥미로워집니다...
6. 환경이 생성됩니다.
7. 값 '2'가 환경에서 이름 'x'에 바인딩됩니다.
8. 표현식 'x'(함수의 오른쪽)가 방금 생성한 환경 내에서 평가됩니다.
9. 환경에서 평가될 때 변수의 값은 그 환경에서 변수 이름에 바인딩된 값인 '2'입니다.
10. 그리고 그것이 우리의 결과입니다.

환경에 대해 이야기할 때, 우리는 바인딩을 보여주기 위해 놀랍지 않은 구문을 사용할 것입니다[json]: `{x: 2, ...}`는 환경이 사전이고, 값 `2`가 이름 `x`에 바인딩되어 있으며, 지금 논의하지 않는 다른 것들이 그 사전에 있을 수 있다는 것을 의미합니다.

[json]: http://json.org/

### 공유에 의한 호출 {#call-by-sharing}

앞서 우리는 JavaScript의 *값 타입*과 *참조 타입*을 구별했습니다. 그때 우리는 JavaScript가 동일한 객체와 그렇지 않은 객체를 어떻게 구별하는지 살펴보았습니다. 이제 값 타입과 참조 타입의 구별을 다시 한번 살펴볼 때입니다.

JavaScript가 엄격하게 유지하는 속성이 하나 있습니다: 어떤 값이든 함수의 인자로 전달될 때, 함수의 환경에 바인딩되는 값은 원래 값과 동일해야 합니다.

우리는 JavaScript가 이름을 값에 바인딩한다고 말했지만, 이름을 값에 바인딩한다는 것이 무엇을 의미하는지는 말하지 않았습니다. 이제 자세히 설명하겠습니다: JavaScript가 값 타입을 이름에 바인딩할 때, 값의 복사본을 만들어 그 복사본을 환경에 넣습니다. 기억하시듯이, 문자열이나 숫자와 같은 값 타입은 같은 내용을 가지고 있다면 서로 동일합니다. 따라서 JavaScript는 원하는 만큼 문자열, 숫자, 또는 불리언의 복사본을 만들 수 있습니다.

참조 타입은 어떨까. JavaScript는 참조값의 복사본을 어떤 환경에도 저장하지 않습니다. JavaScript는 환경에 참조 타입에 대한 참조를 저장하고, 값을 사용해야 할 때 그 참조를 통해 원본을 가져옵니다.

여러 참조가 동일한 값을 공유할 수 있고 JavaScript가 인자로 참조를 전달하기 때문에, JavaScript는 "공유에 의한 호출(call by sharing)" 의미론을 구현한다고 할 수 있습니다. 공유에 의한 호출은 일반적으로 값에 의한 호출(call by value)의 특수한 형태로 이해되며, 이는 어떤 값들이 값 타입으로, 다른 값들이 참조 타입으로 알려지게 된 이유를 설명합니다.

이제 클로저를 살펴볼 준비가 되었습니다. 값 타입, 참조 타입, 인자, 그리고 클로저에 대한 우리의 지식을 종합하면, 다음 함수가 어떤 인자[^NaNPedantry]를 적용하더라도 항상 true로 평가되는 이유를 이해할 수 있을 것입니다:


    (value) =>
      ((ref1, ref2) => ref1 === ref2)(value, value)

[^NaNPedantry]: NaN을 인자로 사용하는 경우는 예외입니다. NaN은 자기 자신을 포함해서 어떤 것과도 동일하지 않습니다. JavaScript의 NaN은 SQL의 NULL과 매우 비슷하게 동작합니다
