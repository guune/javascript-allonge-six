# 빈(Bean) 고르기: 선택과 진실

![Decaf and the Antidote](../images/antidote.jpg)

우리는 `+`와 `%` 같이 숫자 값에 작용하는 연산자들을 보았습니다. 숫자 외에도, 우리는 종종 참 또는 거짓이라는 더 기본적인 개념을 표현할 필요가 있습니다. 이 배열이 비어 있나요? 이 사람은 중간 이름이 있나요? 이 사용자가 로그인했나요?

JavaScript에는 "불리언" 값이 있으며, 이는 `true`와 `false`로 작성됩니다:

    true
      //=> true

    false
      //=> false

`true`와 `false`는 값 타입입니다. 모든 `true` 값은 다른 모든 `true` 값과 `===`입니다. 우리는 불리언 값에 수행할 수 있는 연산자인 `!`, `&&`, `||`를 살펴봄으로써 이를 확인할 수 있습니다.   
우선, `!`는 인수를 부정하는 단항 전위 연산자입니다. 따라서:

    !true
      //=> false

    !false
      //=> true

`&&`와 `||` 연산자는 각각 "논리적 AND"와 "논리적 OR"를 수행하는 이항 중위 연산자입니다:

    false && false //=> false
    false && true  //=> false
    true  && false //=> false
    true  && true  //=> true

    false || false //=> false
    false || true  //=> true
    true  || false //=> true
    true  || true  //=> true

이제 주목할 점: 우리는 불리언 값을 `!`, `&&`, `||`에 전달할 때 어떤 일이 일어나는지는 설명했지만, 표현식이나 다른 값을 전달하는 것에 대해서는 아무 말도 하지 않았습니다. 이에 대해 곧 살펴보겠습니다.

### 참됨과 삼항 연산자


JavaScript에는 "참됨(truthiness)"이라는 개념이 있습니다. 모든 값은 "참 같은(truthy)" 또는 "거짓 같은(falsy)" 것입니다. 당연히, false는 거짓 같습니다. null과 undefined도 마찬가지인데, 이들은 의미상 "값 없음"을 나타냅니다. NaN도 거짓 같으며, 이는 숫자가 아닌 계산 결과를 나타내는 값입니다.[^NaN] 그리고 더 있습니다: 0은 거짓 같으며, "무언가가 없음"을 나타내는 값입니다. 빈 문자열 ''도 거짓 같으며, 문자가 없음을 나타내는 값입니다.

[^NaN]: 우리는 이 책에서 JavaScript의 숫자 동작에 대해 깊이 다루지 않을 것이지만, 가장 중요한 것은 IEEE(전기전자공학회)가 1985년에 제정한 기술 표준인 IEEE 부동소수점 연산 표준(IEEE 754)을 구현한다는 것입니다.[ IEEE Standard for Floating-Point Arithmetic (IEEE 754)](https://en.wikipedia.org/wiki/IEEE_floating_point)

앞서 언급한 `false`, `null`, `undefined`, `NaN`, `0`, `''`를 제외한 JavaScript의 다른 모든 값은 "참 같습니다". (다른 많은 언어들에서는 참됨의 개념이 있지만 0과 빈 문자열을 거짓 같은 것이 아닌 참 같은 것으로 간주하므로, 한 언어의 코드를 다른 언어로 맹목적으로 옮기는 것을 주의하세요!)

참됨이 중요한 이유는 다양한 논리 연산자들(그리고 if 문)이 실제로 불리언 값이 아닌 참됨에 대해 작동하기 때문입니다. 이는 `!`, `&&`, `||` 연산자의 작동 방식에 영향을 미칩니다. 이들에 대해서는 잠시 후에 살펴보겠지만, 먼저 하나의 연산자를 더 살펴보겠습니다.

JavaScript는 C 계열 언어에서 삼항 연산자를 물려받았습니다. 이는 세 개의 인수를 취하는 유일한 연산자입니다. 이는 다음과 같이 생겼습니다: `first ? second : third`. 이는 `first`를 평가하고, 만약 `first`가 "참 같으면", `second`를 평가하고 그 값이 결과가 됩니다. 만약 `first`가 참 같지 않다면, `third`를 평가하고 그 값이 결과가 됩니다.

이는 if 문과 매우 비슷하지만, 이는 문이 아닌 *표현식*이며, 이는 매우 가치있을 수 있습니다. 또한 중괄호를 도입하지 않으며, 이는 새로운 스코프를 도입하거나 문을 사용하고자 할 때 도움이 될 수도 있고 방해가 될 수도 있습니다.

다음은 삼항 연산자의 간단한 예시들입니다:

    true ? 'Hello' : 'Good bye'
      //=> 'Hello'

    0 ? 'Hello' : 'Good bye'
      //=> 'Good bye'

    [1, 2, 3, 4, 5].length === 5 ? 'Pentatonic' : 'Quasimodal'
      //=> 'Pentatonic'

두 번째나 세 번째 표현식 중 하나만 평가된다는 사실(둘 다는 아님)은 중요한 영향을 미칠 수 있습니다. 이 가상의 예시를 고려해보세요:

    const status = isAuthorized(currentUser) ? deleteRecord(currentRecord) : 'Forbidden';

우리는 확실히 `isAuthorized(currentUser)`가 `true`를 반환하지 않는 한 JavaScript가 `deleteRecord(currentRecord)`를 평가하려고 하는 것을 원하지 않습니다.

### 참됨과 연산자들

우리의 논리 연산자 `!`, `&&`, `||`는 위의 예시들이 암시한 것보다 조금 더 미묘합니다. `!`가 가장 단순합니다. 이는 인수가 참 같으면 항상 `false`를 반환하고, 인수가 참 같지 않으면 `true`를 반환합니다:

    !5
      //=> false

    !undefined
      //=> true

프로그래머들은 종종 이 동작을 이용하여 `!!(someExpression)`이 `someExpression`이 참 같으면 항상 `true`로 평가되고, 그렇지 않으면 `false`로 평가된다는 것을 관찰합니다. 따라서 JavaScript(그리고 비슷한 의미를 가진 다른 언어들)에서, !!currentUser()와 같은 것을 볼 때, 이는 "currentUser가 참 같으면 true"라는 의미의 관용구입니다. 따라서, currentUser()와 같은 함수는 현재 사용자가 없는 경우 `null`, 또는 `undefined`, 또는 `false`를 반환할 수 있습니다.


따라서, `!!`은 JavaScript에서 "참 같다"를 쓰는 방법입니다. `&&`와 `||`는 어떨까요? 우리가 아직 논의하지 않은 것은 무엇일까요?

첫째, 그리고 !와는 달리, &&와 ||는 반드시 true 또는 false로 평가되지는 않습니다. 정확히 말하면:

- &&는 왼쪽 표현식을 평가합니다.
    - 만약 왼쪽 표현식이 거짓 같은 것으로 평가되면, &&는 오른쪽 표현식을 평가하지 않고 왼쪽 표현식의 값을 반환합니다.
    - 만약 왼쪽 표현식이 참 같은 것으로 평가되면, &&는 오른쪽 표현식을 평가하고 오른쪽 표현식의 값을 반환합니다.


- ||는 왼쪽 표현식을 평가합니다.
    - 만약 왼쪽 표현식이 참 같은 것으로 평가되면, ||는 오른쪽 표현식을 평가하지 않고 왼쪽 표현식의 값을 반환합니다.
    - 만약 왼쪽 표현식이 거짓으로 평가되면, ||는 오른쪽 표현식을 평가하고 오른쪽 표현식의 값을 반환합니다.

위의 예시들을 보면, `true`와 `false`를 `&&`와 `||`에 전달할 때 실제로 결과로 `true` 또는 `false`를 얻는 것을 볼 수 있습니다. 하지만 다른 값들을 전달할 때는 더 이상 `true` 또는 `false`를 얻지 않습니다:

    1 || 2
      //=> 1

    null && undefined
      //=> null

    undefined && null
      //=> undefined

JavaScript에서, `&&`와 `||`는 논리적 의미에서의 불리언 논리 연산자가 아닙니다. 이들은 논리적 값에만 엄격하게 작동하지 않으며, 교환법칙이 성립하지 않습니다: a || b는 항상 b || a와 같지 않으며, &&도 마찬가지입니다.

이는 미묘한 차이가 아닙니다.

### `||`와 `&&`는 제어 흐름 연산자입니다

우리는 삼항 연산자를 보았습니다: 이는 논리 연산자가 아닌 제어 흐름 연산자입니다. `&&`와 `||`도 마찬가지입니다. 양의 정수가 짝수인지 판단하는 이 꼬리 재귀 함수를 고려해보세요:

For example:

    const even = (n) =>
      n === 0 || (n !== 1 && even(n - 2))

    even(42)
      //=> true

만약 `n === 0`이면, JavaScript는 `(n !== 1 && even(n - 2))`를 평가하지 않습니다. 이는 매우 중요합니다! JavaScript가 값을 결정하기 전에 `||` 연산자의 양쪽을 모두 평가한다고 상상해보세요. `n === 0`은 참일 것입니다. `(n !== 1 && even(n - 2))`는 어떨까요? 음, 이는 `even(n - 2)`, 또는 `even(-2)`를 평가할 것입니다.

이는 우리가 다시 `n === 0 || (n !== 1 && even(n - 2))`를 평가하게 되고, 이번에는 `even(-4)`를 평가하게 됩니다. 그리고 `even(-6`)을 평가합니다. 그리고 이런 식으로 계속되어 JavaScript가 포기하고 스택 공간이 부족해질 때까지 계속됩니다.

하지만 그런 일은 일어나지 않습니다. ||와 &&는 *단축 평가 의미*를 가집니다. 이 경우, 만약 n === 0이면, JavaScript는 (n !== 1 && even(n - 2))를 평가하지 않습니다. 마찬가지로, 만약 n === 1이면, JavaScript는 even(n - 2)를 전혀 평가하지 않고 n !== 1 && even(n - 2)를 false로 평가합니다.

이는 단순한 최적화 이상입니다. `||`와 `&&`를 제어 흐름 연산자로 생각하는 것이 가장 좋습니다. 왼쪽의 표현식은 항상 평가되며, 그 값이 오른쪽 표현식의 평가 여부를 결정합니다.

### 함수 매개변수는 즉시 평가됩니다

`삼항 연산자`, `||`, `&&`의 동작과는 대조적으로, 함수 매개변수는 항상 즉시 평가됩니다:

    const or = (a, b) => a || b

    const and = (a, b) => a && b

    const even = (n) =>
      or(n === 0, and(n !== 1, even(n - 2)))

    even(42)
      //=> Maximum call stack size exceeded.

이제 우리의 표현식 `or(n === 0, and(n !== 1, even(n - 2)))`는 함수를 호출하고 있으며, JavaScript는 항상 함수를 호출하기 위해 값을 전달하기 전에 매개변수에 대한 표현식을 평가합니다. 이는 우리가 두려워하는 무한 재귀로 이어집니다

제어 흐름 의미론을 가진 함수가 필요한 경우, 익명 함수를 전달할 수 있습니다. `or`와 `and`에 대해 이와 같은 것이 필요하지는 않지만, 기술을 시연하기 위해:


    const or = (a, b) => a() || b()

    const and = (a, b) => a() && b()

    const even = (n) =>
      or(() => n === 0, () => and(() => n !== 1, () => even(n - 2)))

    even(7)
      //=> false

여기서 우리는 평가하고자 하는 표현식을 포함하는 함수를 전달했고, 이제 평가를 지연시킬 수 있는 우리만의 함수를 작성할 수 있습니다.

### summary

- 논리 연산자는 엄격한 true와 false 값이 아닌 참과 거짓에 기반합니다.
- !는 논리 연산자이며, 항상 true 또는 false를 반환합니다.
- 삼항 연산자(?:), ||, &&는 제어 흐름 연산자이며, 항상 true 또는 false를 반환하지 않고, 단축 평가 의미론을 가집니다.
- 함수 호출은 즉시 평가를 사용하므로, 우리만의 제어 흐름 의미론이 필요한 경우 표현식이 아닌 함수를 전달합니다.
